{"version":3,"file":"testing.d.ts","sources":["testing.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v11.2.14\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { AbstractType } from '@angular/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { Compiler } from '@angular/core';\nimport { CompilerOptions } from '@angular/core';\nimport { Component } from '@angular/core';\nimport { ComponentFactory } from '@angular/core';\nimport { ComponentRef } from '@angular/core';\nimport { DebugElement } from '@angular/core';\nimport { Directive } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { InjectFlags } from '@angular/core';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { NgModule } from '@angular/core';\nimport { NgZone } from '@angular/core';\nimport { Pipe } from '@angular/core';\nimport { PlatformRef } from '@angular/core';\nimport { SchemaMetadata } from '@angular/core';\nimport { Type } from '@angular/core';\n\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\nexport declare const __core_private_testing_placeholder__ = \"\";\n\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nexport declare function async(fn: Function): (done: any) => any;\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nexport declare class ComponentFixture<T> {\n    componentRef: ComponentRef<T>;\n    ngZone: NgZone | null;\n    private _autoDetect;\n    /**\n     * The DebugElement associated with the root element of this component.\n     */\n    debugElement: DebugElement;\n    /**\n     * The instance of the root component class.\n     */\n    componentInstance: T;\n    /**\n     * The native element at the root of the component.\n     */\n    nativeElement: any;\n    /**\n     * The ElementRef for the element at the root of the component.\n     */\n    elementRef: ElementRef;\n    /**\n     * The ChangeDetectorRef for the component\n     */\n    changeDetectorRef: ChangeDetectorRef;\n    private _renderer;\n    private _isStable;\n    private _isDestroyed;\n    private _resolve;\n    private _promise;\n    private _onUnstableSubscription;\n    private _onStableSubscription;\n    private _onMicrotaskEmptySubscription;\n    private _onErrorSubscription;\n    constructor(componentRef: ComponentRef<T>, ngZone: NgZone | null, _autoDetect: boolean);\n    private _tick;\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges?: boolean): void;\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges(): void;\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    autoDetectChanges(autoDetect?: boolean): void;\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable(): boolean;\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable(): Promise<any>;\n    private _getRenderer;\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone(): Promise<any>;\n    /**\n     * Trigger component destruction.\n     */\n    destroy(): void;\n}\n\n/**\n * @publicApi\n */\nexport declare const ComponentFixtureAutoDetect: InjectionToken<boolean[]>;\n\n/**\n * @publicApi\n */\nexport declare const ComponentFixtureNoNgZone: InjectionToken<boolean[]>;\n\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nexport declare function discardPeriodicTasks(): void;\n\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @publicApi\n */\nexport declare function fakeAsync(fn: Function): (...args: any[]) => any;\n\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @publicApi\n */\nexport declare function flush(maxTurns?: number): number;\n\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nexport declare function flushMicrotasks(): void;\n\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\nexport declare const getTestBed: () => TestBed;\n\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * Notes:\n * - inject is currently a function because of some Traceur limitation the syntax should\n * eventually\n *   becomes `it('...', @Inject (object: AClass, async: AsyncTestCompleter) => { ... });`\n *\n * @publicApi\n */\nexport declare function inject(tokens: any[], fn: Function): () => any;\n\n/**\n * @publicApi\n */\nexport declare class InjectSetupWrapper {\n    private _moduleDef;\n    constructor(_moduleDef: () => TestModuleMetadata);\n    private _addModule;\n    inject(tokens: any[], fn: Function): () => any;\n}\n\n\n/**\n * Type used for modifications to metadata\n *\n * @publicApi\n */\nexport declare type MetadataOverride<T> = {\n    add?: Partial<T>;\n    remove?: Partial<T>;\n    set?: Partial<T>;\n};\n\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nexport declare function resetFakeAsyncZone(): void;\n\n/**\n * @publicApi\n */\nexport declare interface TestBed {\n    platform: PlatformRef;\n    ngModule: Type<any> | Type<any>[];\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void;\n    /**\n     * Reset the providers for the test injector.\n     */\n    resetTestEnvironment(): void;\n    resetTestingModule(): void;\n    configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): void;\n    configureTestingModule(moduleDef: TestModuleMetadata): void;\n    compileComponents(): Promise<any>;\n    inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T | null;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token: any, notFoundValue?: any): any;\n    execute(tokens: any[], fn: Function, context?: any): any;\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    overrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    overrideProvider(token: any, provider: {\n        useFactory?: Function;\n        useValue?: any;\n        deps?: any[];\n    }): void;\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\n}\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\nexport declare const TestBed: TestBedStatic;\n\n/**\n * Static methods implemented by the `TestBedViewEngine` and `TestBedRender3`\n *\n * @publicApi\n */\nexport declare interface TestBedStatic {\n    new (...args: any[]): TestBed;\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): TestBed;\n    /**\n     * Reset the providers for the test injector.\n     */\n    resetTestEnvironment(): void;\n    resetTestingModule(): TestBedStatic;\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n    configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): TestBedStatic;\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    compileComponents(): Promise<any>;\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\n    overrideTemplate(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): TestBedStatic;\n    overrideProvider(token: any, provider: {\n        useValue: any;\n    }): TestBedStatic;\n    overrideProvider(token: any, provider: {\n        useFactory?: Function;\n        useValue?: any;\n        deps?: any[];\n    }): TestBedStatic;\n    inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T | null;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token: any, notFoundValue?: any): any;\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\n}\n\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nexport declare class TestComponentRenderer {\n    insertRootElement(rootElementId: string): void;\n}\n\n/**\n * @publicApi\n */\nexport declare type TestModuleMetadata = {\n    providers?: any[];\n    declarations?: any[];\n    imports?: any[];\n    schemas?: Array<SchemaMetadata | any[]>;\n    aotSummaries?: () => any[];\n};\n\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param millis, the number of millisecond to advance the virtual timer\n * @param tickOptions, the options of tick with a flag called\n * processNewMacroTasksSynchronously, whether to invoke the new macroTasks, by default is\n * false, means the new macroTasks will be invoked\n *\n * For example,\n *\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n *\n * in this case, we have a nested timeout (new macroTask), when we tick, both the\n * funcWithNestedTimeout and the nested timeout both will be invoked.\n *\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n *\n * if we pass the tickOptions with processNewMacroTasksSynchronously to be false, the nested timeout\n * will not be invoked.\n *\n *\n * @publicApi\n */\nexport declare function tick(millis?: number, tickOptions?: {\n    processNewMacroTasksSynchronously: boolean;\n}): void;\n\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nexport declare function waitForAsync(fn: Function): (done: any) => any;\n\n/**\n * @publicApi\n */\nexport declare function withModule(moduleDef: TestModuleMetadata): InjectSetupWrapper;\n\nexport declare function withModule(moduleDef: TestModuleMetadata, fn: Function): () => any;\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nexport declare class ɵangular_packages_core_testing_testing_a implements TestBed {\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    static initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): ɵangular_packages_core_testing_testing_a;\n    /**\n     * Reset the providers for the test injector.\n     */\n    static resetTestEnvironment(): void;\n    static resetTestingModule(): TestBedStatic;\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n    static configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): TestBedStatic;\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents(): Promise<any>;\n    static overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\n    static overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\n    static overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\n    static overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\n    static overrideTemplate(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): TestBedStatic;\n    static overrideProvider(token: any, provider: {\n        useValue: any;\n    }): TestBedStatic;\n    static inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    static inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T | null;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n    /**\n     * @deprecated from v9.0.0 use TestBed.inject\n     * @suppress {duplicate}\n     */\n    static get(token: any, notFoundValue?: any): any;\n    static createComponent<T>(component: Type<T>): ComponentFixture<T>;\n    private _instantiated;\n    private _compiler;\n    private _moduleRef;\n    private _moduleFactory;\n    private _compilerOptions;\n    private _moduleOverrides;\n    private _componentOverrides;\n    private _directiveOverrides;\n    private _pipeOverrides;\n    private _providers;\n    private _declarations;\n    private _imports;\n    private _schemas;\n    private _activeFixtures;\n    private _testEnvAotSummaries;\n    private _aotSummaries;\n    private _templateOverrides;\n    private _isRoot;\n    private _rootProviderOverrides;\n    platform: PlatformRef;\n    ngModule: Type<any> | Type<any>[];\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void;\n    /**\n     * Reset the providers for the test injector.\n     */\n    resetTestEnvironment(): void;\n    resetTestingModule(): void;\n    configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): void;\n    configureTestingModule(moduleDef: TestModuleMetadata): void;\n    compileComponents(): Promise<any>;\n    private _initIfNeeded;\n    private _createCompilerAndModule;\n    private _assertNotInstantiated;\n    inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T | null;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token: any, notFoundValue?: any): any;\n    execute(tokens: any[], fn: Function, context?: any): any;\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): void;\n    overrideProvider(token: any, provider: {\n        useValue: any;\n    }): void;\n    private overrideProviderImpl;\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\n    createComponent<T>(component: Type<T>): ComponentFixture<T>;\n}\n\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nexport declare class ɵangular_packages_core_testing_testing_b implements TestBed {\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): TestBed;\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment(): void;\n    static configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): TestBedStatic;\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef: TestModuleMetadata): TestBedStatic;\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents(): Promise<any>;\n    static overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): TestBedStatic;\n    static overrideComponent(component: Type<any>, override: MetadataOverride<Component>): TestBedStatic;\n    static overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): TestBedStatic;\n    static overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): TestBedStatic;\n    static overrideTemplate(component: Type<any>, template: string): TestBedStatic;\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component: Type<any>, template: string): TestBedStatic;\n    static overrideProvider(token: any, provider: {\n        useFactory: Function;\n        deps: any[];\n    }): TestBedStatic;\n    static overrideProvider(token: any, provider: {\n        useValue: any;\n    }): TestBedStatic;\n    static inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    static inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T | null;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token: any, notFoundValue?: any): any;\n    static createComponent<T>(component: Type<T>): ComponentFixture<T>;\n    static resetTestingModule(): TestBedStatic;\n    platform: PlatformRef;\n    ngModule: Type<any> | Type<any>[];\n    private _compiler;\n    private _testModuleRef;\n    private _activeFixtures;\n    private _globalCompilationChecked;\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule: Type<any> | Type<any>[], platform: PlatformRef, aotSummaries?: () => any[]): void;\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment(): void;\n    resetTestingModule(): void;\n    configureCompiler(config: {\n        providers?: any[];\n        useJit?: boolean;\n    }): void;\n    configureTestingModule(moduleDef: TestModuleMetadata): void;\n    compileComponents(): Promise<any>;\n    inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue?: T, flags?: InjectFlags): T;\n    inject<T>(token: Type<T> | InjectionToken<T> | AbstractType<T>, notFoundValue: null, flags?: InjectFlags): T | null;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): any;\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token: any, notFoundValue?: any): any;\n    execute(tokens: any[], fn: Function, context?: any): any;\n    overrideModule(ngModule: Type<any>, override: MetadataOverride<NgModule>): void;\n    overrideComponent(component: Type<any>, override: MetadataOverride<Component>): void;\n    overrideTemplateUsingTestingModule(component: Type<any>, template: string): void;\n    overrideDirective(directive: Type<any>, override: MetadataOverride<Directive>): void;\n    overridePipe(pipe: Type<any>, override: MetadataOverride<Pipe>): void;\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token: any, provider: {\n        useFactory?: Function;\n        useValue?: any;\n        deps?: any[];\n    }): void;\n    createComponent<T>(type: Type<T>): ComponentFixture<T>;\n    private assertNotInstantiated;\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    private checkGlobalCompilationFinished;\n    private destroyActiveFixtures;\n}\n\nexport declare function ɵangular_packages_core_testing_testing_c(): ɵangular_packages_core_testing_testing_b;\n\nexport declare class ɵMetadataOverrider {\n    private _references;\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata<C extends T, T>(metadataClass: {\n        new (options: T): C;\n    }, oldMetadata: C, override: MetadataOverride<T>): C;\n}\n\n/**\n * Special interface to the compiler only used by testing\n *\n * @publicApi\n */\nexport declare class ɵTestingCompiler extends Compiler {\n    get injector(): Injector;\n    overrideModule(module: Type<any>, overrides: MetadataOverride<NgModule>): void;\n    overrideDirective(directive: Type<any>, overrides: MetadataOverride<Directive>): void;\n    overrideComponent(component: Type<any>, overrides: MetadataOverride<Component>): void;\n    overridePipe(directive: Type<any>, overrides: MetadataOverride<Pipe>): void;\n    /**\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n     * so that it can use the code generated by AOT.\n     */\n    loadAotSummaries(summaries: () => any[]): void;\n    /**\n     * Gets the component factory for the given component.\n     * This assumes that the component has been compiled before calling this call using\n     * `compileModuleAndAllComponents*`.\n     */\n    getComponentFactory<T>(component: Type<T>): ComponentFactory<T>;\n    /**\n     * Returns the component type that is stored in the given error.\n     * This can be used for errors created by compileModule...\n     */\n    getComponentFromError(error: Error): Type<any> | null;\n}\n\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\nexport declare abstract class ɵTestingCompilerFactory {\n    abstract createTestingCompiler(options?: CompilerOptions[]): ɵTestingCompiler;\n}\n\nexport { }\n"]}