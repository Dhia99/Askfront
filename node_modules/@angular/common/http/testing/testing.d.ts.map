{"version":3,"file":"testing.d.ts","sources":["testing.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA","sourcesContent":["/**\n * @license Angular v11.2.14\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { HttpBackend } from '@angular/common/http';\nimport { HttpEvent } from '@angular/common/http';\nimport { HttpHeaders } from '@angular/common/http';\nimport { HttpRequest } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { Observer } from 'rxjs';\n\n\n/**\n * Configures `HttpClientTestingBackend` as the `HttpBackend` used by `HttpClient`.\n *\n * Inject `HttpTestingController` to expect and flush requests in your tests.\n *\n * @publicApi\n */\nexport declare class HttpClientTestingModule {\n}\n\n/**\n * Controller to be injected into tests, that allows for mocking and flushing\n * of requests.\n *\n * @publicApi\n */\nexport declare abstract class HttpTestingController {\n    /**\n     * Search for requests that match the given parameter, without any expectations.\n     */\n    abstract match(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean)): TestRequest[];\n    /**\n     * Expect that a single request has been made which matches the given URL, and return its\n     * mock.\n     *\n     * If no such request has been made, or more than one such request has been made, fail with an\n     * error message including the given request description, if any.\n     */\n    abstract expectOne(url: string, description?: string): TestRequest;\n    /**\n     * Expect that a single request has been made which matches the given parameters, and return\n     * its mock.\n     *\n     * If no such request has been made, or more than one such request has been made, fail with an\n     * error message including the given request description, if any.\n     */\n    abstract expectOne(params: RequestMatch, description?: string): TestRequest;\n    /**\n     * Expect that a single request has been made which matches the given predicate function, and\n     * return its mock.\n     *\n     * If no such request has been made, or more than one such request has been made, fail with an\n     * error message including the given request description, if any.\n     */\n    abstract expectOne(matchFn: ((req: HttpRequest<any>) => boolean), description?: string): TestRequest;\n    /**\n     * Expect that a single request has been made which matches the given condition, and return\n     * its mock.\n     *\n     * If no such request has been made, or more than one such request has been made, fail with an\n     * error message including the given request description, if any.\n     */\n    abstract expectOne(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): TestRequest;\n    /**\n     * Expect that no requests have been made which match the given URL.\n     *\n     * If a matching request has been made, fail with an error message including the given request\n     * description, if any.\n     */\n    abstract expectNone(url: string, description?: string): void;\n    /**\n     * Expect that no requests have been made which match the given parameters.\n     *\n     * If a matching request has been made, fail with an error message including the given request\n     * description, if any.\n     */\n    abstract expectNone(params: RequestMatch, description?: string): void;\n    /**\n     * Expect that no requests have been made which match the given predicate function.\n     *\n     * If a matching request has been made, fail with an error message including the given request\n     * description, if any.\n     */\n    abstract expectNone(matchFn: ((req: HttpRequest<any>) => boolean), description?: string): void;\n    /**\n     * Expect that no requests have been made which match the given condition.\n     *\n     * If a matching request has been made, fail with an error message including the given request\n     * description, if any.\n     */\n    abstract expectNone(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): void;\n    /**\n     * Verify that no unmatched requests are outstanding.\n     *\n     * If any requests are outstanding, fail with an error message indicating which requests were not\n     * handled.\n     *\n     * If `ignoreCancelled` is not set (the default), `verify()` will also fail if cancelled requests\n     * were not explicitly matched.\n     */\n    abstract verify(opts?: {\n        ignoreCancelled?: boolean;\n    }): void;\n}\n\n/**\n * Defines a matcher for requests based on URL, method, or both.\n *\n * @publicApi\n */\nexport declare interface RequestMatch {\n    method?: string;\n    url?: string;\n}\n\n/**\n * A mock requests that was received and is ready to be answered.\n *\n * This interface allows access to the underlying `HttpRequest`, and allows\n * responding with `HttpEvent`s or `HttpErrorResponse`s.\n *\n * @publicApi\n */\nexport declare class TestRequest {\n    request: HttpRequest<any>;\n    private observer;\n    /**\n     * Whether the request was cancelled after it was sent.\n     */\n    get cancelled(): boolean;\n    constructor(request: HttpRequest<any>, observer: Observer<HttpEvent<any>>);\n    /**\n     * Resolve the request by returning a body plus additional HTTP information (such as response\n     * headers) if provided.\n     * If the request specifies an expected body type, the body is converted into the requested type.\n     * Otherwise, the body is converted to `JSON` by default.\n     *\n     * Both successful and unsuccessful responses can be delivered via `flush()`.\n     */\n    flush(body: ArrayBuffer | Blob | boolean | string | number | Object | (boolean | string | number | Object | null)[] | null, opts?: {\n        headers?: HttpHeaders | {\n            [name: string]: string | string[];\n        };\n        status?: number;\n        statusText?: string;\n    }): void;\n    /**\n     * Resolve the request by returning an `ErrorEvent` (e.g. simulating a network failure).\n     */\n    error(error: ErrorEvent, opts?: {\n        headers?: HttpHeaders | {\n            [name: string]: string | string[];\n        };\n        status?: number;\n        statusText?: string;\n    }): void;\n    /**\n     * Deliver an arbitrary `HttpEvent` (such as a progress event) on the response stream for this\n     * request.\n     */\n    event(event: HttpEvent<any>): void;\n}\n\n/**\n * A testing backend for `HttpClient` which both acts as an `HttpBackend`\n * and as the `HttpTestingController`.\n *\n * `HttpClientTestingBackend` works by keeping a list of all open requests.\n * As requests come in, they're added to the list. Users can assert that specific\n * requests were made and then flush them. In the end, a verify() method asserts\n * that no unexpected requests were made.\n *\n *\n */\nexport declare class Éµangular_packages_common_http_testing_testing_a implements HttpBackend, HttpTestingController {\n    /**\n     * List of pending requests which have not yet been expected.\n     */\n    private open;\n    /**\n     * Handle an incoming request by queueing it in the list of open requests.\n     */\n    handle(req: HttpRequest<any>): Observable<HttpEvent<any>>;\n    /**\n     * Helper function to search for requests in the list of open requests.\n     */\n    private _match;\n    /**\n     * Search for requests in the list of open requests, and return all that match\n     * without asserting anything about the number of matches.\n     */\n    match(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean)): TestRequest[];\n    /**\n     * Expect that a single outstanding request matches the given matcher, and return\n     * it.\n     *\n     * Requests returned through this API will no longer be in the list of open requests,\n     * and thus will not match twice.\n     */\n    expectOne(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): TestRequest;\n    /**\n     * Expect that no outstanding requests match the given matcher, and throw an error\n     * if any do.\n     */\n    expectNone(match: string | RequestMatch | ((req: HttpRequest<any>) => boolean), description?: string): void;\n    /**\n     * Validate that there are no outstanding requests.\n     */\n    verify(opts?: {\n        ignoreCancelled?: boolean;\n    }): void;\n    private descriptionFromMatcher;\n}\n\nexport { }\n"]}